
**FFT란?** <br>

<img width="800" alt="image" src="https://github.com/user-attachments/assets/a09e11f8-483d-4b9a-be05-764e73d76ca3" /> |
--|

- 그림과 같이 시간 도메인의 함수를 주파수 도메인 함수로 변환하는것을 푸리에 변환이라고 합니다.

- 하지만 이산적인(무한하지 않은) 영역에서 DFT(이산 푸리에 변환)은 샘플링 수에 따라 기하 급수적으로 연산양이 커지게 됩니다.

- 이를 빠르게 계산하기 위해서 사용되는것이 FFT로 연상양이 획기적으로 줄어들어 듭니다.

- IFFT 같은 경우에는 주파수 도메인 함수에서 시간도메인 함수로 변환하는 과정으로 FFT과정과 비슷하지만 1/N 스케일링 과정이 추가 됩니다.

**FFT의 필요성**
- **시간 영역 신호를 주파수 영역으로 변환**하여 주파수 분석, 채널 분리 등 다양한 신호 처리에 활용 가능.

- 통신 시스템(OFDM, 5G, Wi-Fi), 레이더, 오디오·영상 처리 등 **실시간·고속 신호 처리**가 필요한 대부분의 시스템에서 핵심 알고리즘으로 사용됨.

**HW가 적합한 이유**

- **FFT 연산**은 곱셈과 덧셈이 반복되는 **고연산량 알고리즘**으로, 소프트웨어에서는 처리 속도와 전력 효율이 제한됨.

- 하드웨어에서는 **병렬 연산, 파이프라인 구조, 메모리 최적화**를 통해 **실시간** 처리가 가능.

- RTL 설계 및 FPGA 구현을 통해 setup time, area, latency 등의 특성을 직접 분석하고 최적화 가능.

- 결과적으로 실시간 통신 및 신호 처리 시스템에서 **고속·저전력 FFT 구현**이 가능함.



### 🧐문제 인식
**HW 설계가 더 적합한 이유**
- 일반적인 FFT 알고리즘을 RTL로 구현하기에는 많은 연산을 특히 복소수 곱셈 연산을 하게되어 리소스가 커지게 됩니다. <br>
그렇기 떄문에 저희는 Radix-2^2 논문을 해석하여 논문 내용을 바탕으로 만들어진 Fixed_model을 분석하였습니다. <br>
- 논문에서 사용하는 방법론은 버터플라이 연산은 Radix-2 방식으러 진행하여 연산이 간단하며 회전인자 곱셈은 Radix-4와 같이 적은 곱셈연산을 수행합니다.
이러한 연산을 수행하는 방법으로는 첫번째 버터플라이 연산후에는 간단한 1,-j와 같은 곱셈을 진행하는데 이때는 멀티플라이어가 필요가 없게됩니다.
두번째 버터플라이 연산후에는 복잡한 회전인자 곱셈연산이 추가되지만 다음번 버터플라이 연산때는 다시 단순한 곱셈이 이루어져 결과적으로 필요한 멀티플라이어 갯수가 줄어듭니다.
이러한 연산이 반복되는구조로 샘플링 갯수(N) 가 2의 제곱수이면서 2048이하 일때  하드웨어 구현에 최적화 된 알고리즘 이라는것을 알수 있었습니다.<br>
- Fixed과정에서 saturaion, rounding 과정에서 오차가 발생한다는점을 랜덤입력 과 SQNR을 통해 찾게되어 CBFP논문의 내용또한 해석하여 참조 하였습니다.<br>
- CBFP과정을 추가하여 작은값이 라운딩과정에서 값을 잃어 큰 오차가 발생하는 문제를 작은값이 많은 여유비트를 가진다는 점을 이용하여 MSB쪽으로 값을 이동시켜 라운딩해 값을 최대한 보존하여 높은 SQNR을 얻을수 있었습니다.

